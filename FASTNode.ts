import { Ipv4 } from "./data-structures/ipv4";
import { Protocol, protocols } from "./data-structures/protocol";
import { MAC } from "./data-structures/mac";
import * as fs from 'fs';
import { exec } from "child_process";
import { Port } from "./data-structures/port";

// default directory to export modules to
const DEFAULT_DIR = './output/';

/**
 * FASTNodes - Firewall AST Nodes, are the fundamental building block 
 *  of our compiler. They store internal information to enable call-chaining,
 * and each subclass implements a codeGen() routine to generate C code for
 * the kernel module.
 */
export class FASTNode {

    constructor() { }

    /**
     * Writes complete kernel module to file in default directory
     * @param filename {string} : filename to write module to
     */
    public generate(filename : string) {
        this.optimize();
        if (this instanceof ThenNode)  {
            if (!this.safeTerminal()) {
                throw new Error("Cannot have filter as terminal -> control reaches end of non-void function");
            }
        }
        fs.writeFileSync(`${DEFAULT_DIR}/${filename}`, [
            // we need to default to accept for correct behavior. In the event
            // that any node overrides this, it will return earlier than these,
            // since this is the last call of the chain. Therefore, the node's
            // verdict will override ours here. Otherwise, if none of the nodes override a
            // return verdict, then we need to accept for when the hook is called,
            // it needs a decision for that packet. Also, makes code compile
            // without warnings =)
            this.ingressCodeGen() +  " return NF_ACCEPT;", 
            this.egressCodeGen() +  " return NF_ACCEPT;",
            this.setup()
        ].join('}\n'));
    }

    /**
     * Completes the kernel module with the ending of the C code,
     * closing the required functions that were generated by the other
     * AST nodes.
     * @return {string} : remaining code separated by newline chars
     */
    private setup() : string {
        return [
            'int init_module() {',
                // for ingress hook
                'nfho_ingress.hook = ingress;',
                'nfho_ingress.hooknum = NF_INET_PRE_ROUTING;',
                'nfho_ingress.pf = PF_INET;',
                'nfho_ingress.priority = NF_IP_PRI_FIRST;',
                'nf_register_net_hook(&init_net, &nfho_ingress);',

                // for egress hook
                'nfho_egress.hook = egress;',
                'nfho_egress.hooknum = NF_INET_POST_ROUTING;',
                'nfho_egress.pf = PF_INET;',
                'nfho_egress.priority = NF_IP_PRI_FIRST;',
                'nf_register_net_hook(&init_net, &nfho_egress);',

                'return 0;',
            '}',
            
            'void cleanup_module() {',
                'nf_unregister_net_hook(&init_net, &nfho_ingress);',
                'nf_unregister_net_hook(&init_net, &nfho_egress);',
            '}',
            ''

        ].join('\n');
    }

    public optimize() : FASTNode {
        return this;
    }

    /**
     * @abstract Generates ingress code for this AST node
     * @return {string} : generated code as string
     */
    public ingressCodeGen() : string { 
        return "";
    }

    /**
     * @abstract Generates egress code for this AST node
     * @return {string} : generated code as string
     */
    public egressCodeGen() : string { 
        return "";
    }
}


/**
 * DropNode - drops all incoming packets
 */
export class DropNode extends FASTNode {

    constructor() {
        super();
    }

    ingressCodeGen() : string {
        return "return NF_DROP;";
    }
}

/**
 * IdNode - generates boilerplate code for the module
 */
export class IdNode extends FASTNode {

    constructor() { 
        super();
    }

    public ingressCodeGen() : string {
        return this.initialBoilerplate() + this.boilerplate('ingress');
    }

    public egressCodeGen() : string {
        return this.boilerplate('egress');
    }

    /**
     * Generates initial declarations
     */
    private initialBoilerplate() : string {
        return [
            '#include <linux/kernel.h>',
            '#include <linux/module.h>',
            '#include <linux/netfilter.h>',
            '#include <linux/netfilter_ipv4.h>',
            '#include <linux/ip.h>',
            '#include <linux/string.h>',
            '#include <linux/inet.h>',
            '#include <linux/tcp.h>',
            '#include <linux/udp.h>',

    
            'static struct nf_hook_ops nfho_ingress;',
            'static struct nf_hook_ops nfho_egress;',            
            'struct iphdr* ip_header;',
            'struct sk_buff* sock_buff;',
            'struct ethhdr* ether_header;',
            'struct tcphdr* tcp_header;',
            'struct udphdr* udp_header;',
            ''
        ].join('\n');
    }

    /**
     * Generates boilerplate code for a hook
     * @param functionName hook function name
     */
    private boilerplate(functionName) : string {
        return [
            `unsigned int ${functionName}(void* priv, struct sk_buff* skb,
                     const struct nf_hook_state* state) {`,
    
            'sock_buff = skb;',
    
            'if (!sock_buff) {',
            '   return NF_ACCEPT;',
            '}',
    
            'ip_header = (struct iphdr*) skb_network_header(sock_buff);',
    
            'if (!ip_header) {',
            '   return NF_ACCEPT;',
            '}',
            ''
           ].join('\n');
    }
}

export class FilterNode extends FASTNode {

    private sourcePort : Port;
    private destinationPort : Port;
    private sourceIp : Ipv4;
    private destinationIp : Ipv4;
    private protocol : Protocol;
    private sourceMac : MAC;
    private destinationMac : MAC;

    constructor() { 
        super();
    }

    protected codeGen() : string {
        const code = [];
        if (this.protocol) {
            code.push(`if (ip_header->protocol != ${this.protocol.protocol()}) {
                            return NF_ACCEPT; 
                        }`
                    );
        }
        if (this.sourceIp) {
            code.push(`if (ip_header->saddr != in_aton("${this.sourceIp.asQuad()}")) {
                            return NF_ACCEPT; 
                        }`
                    );
        }

        if (this.destinationIp) {
            code.push(`if (ip_header->daddr != in_aton("${this.destinationIp.asQuad()}")) {
                            return NF_ACCEPT; 
                        }`
                    );
        }

        if (this.destinationMac) {
            code.push(`ether_header = eth_hdr(skb);`);
            code.push(`if (strcmp(ether_header->h_dest, "${this.destinationMac.toString()}") != 0) {
                         return NF_ACCEPT; 
                        }`
                    );
        }

        if (this.sourceMac) {
            code.push(`ether_header = eth_hdr(skb);`);
            code.push(`if (strcmp(ether_header->h_source, "${this.sourceMac.toString()}") != 0) {
                         return NF_ACCEPT; 
                        }`
                    );
        }

        if (this.sourcePort) {
            // need to determine what protocol first
            const proto = this.protocol.protocol();
            if (proto === protocols.TCP) {
                code.push(
                    `tcp_header = tcp_hdr(sock_buff);
                    if (ntohs(tcp_header->source) != ${this.sourcePort.asNumber()}) {
                            return NF_ACCEPT;
                    }`
                );
            } else { 
                // since we've checked that the protocol is either TCP/UDP
                // on setPort, this is UDP.
                code.push(
                    `udp_header = udp_hdr(sock_buff);
                    if (ntohs(udp_header->source) != ${this.sourcePort.asNumber()}) {
                        return NF_ACCEPT;
                    }`
                );
            }
        }

        if (this.destinationPort) {
             // need to determine what protocol first
             const proto = this.protocol.protocol();
             if (proto === protocols.TCP) {
                 code.push(
                     `tcp_header = tcp_hdr(sock_buff);
                     if (ntohs(tcp_header->dest) != ${this.destinationPort.asNumber()}) {
                             return NF_ACCEPT;
                     }`
                 );
             } else { 
                 // since we've checked that the protocol is either TCP/UDP
                 // on setPort, this is UDP.
                 code.push(
                     `udp_header = udp_hdr(sock_buff);
                     if (ntohs(udp_header->dest) != ${this.destinationPort.asNumber()}) {
                         return NF_ACCEPT;
                     }`
                 );
             }
        }

        code.push(''); // just so that we have a newline at the end
        return code.join('\n');
    }

    setSourcePort(port : number) : FilterNode {
        // cannot set any port if not UDP or TCP
        if (this.protocol == null || this.protocol.protocol() === protocols.ICMP) {
            throw new Error("Cannot set port for this protocol");
        }
        this.sourcePort = new Port(port);;
        return this;
    }

    setDestinationPort(port : number) : FilterNode {
        // cannot set any port if not UDP or TCP
        if (this.protocol == null || this.protocol.protocol() === protocols.ICMP) {
            throw new Error("Cannot set port for this protocol");
        }
        this.destinationPort = new Port(port);;
        return this;
    }

    setSourceIp(ip : string) : FilterNode {
        this.sourceIp = new Ipv4(ip);
        return this;
    }

    setDestinationIp(ip : string) : FilterNode {
        this.destinationIp = new Ipv4(ip);;
        return this;
    }

    setProtocol(proto : string) {
        this.protocol = new Protocol(proto);
        return this;
    }

    setSourceMAC(mac : string) {
        this.sourceMac = new MAC(mac);
        return this;
    }

    setDestinationMAC(mac : string) {
        this.destinationMac = new MAC(mac);
        return this;
    }
}

/**
 * IngressFilterNode - filter for ingress traffic
*/
export class IngressFilterNode extends FilterNode {

    constructor() {
        super();
    }

    ingressCodeGen() : string {
        return this.codeGen();
    }
}

/**
 * EgressFilterNode - filter for egress traffic
 */
export class EgressFilterNode extends FilterNode {
    
    constructor() {
        super();
    }

    egressCodeGen() : string {
        return this.codeGen();
    }
}

/**
 * ThenNode - concatenates this node with a second node,
 *             generating code for first then for second, 
 *             and returning the result.
 */
export class ThenNode extends FASTNode {

    protected first : FASTNode;
    protected second : FASTNode;

    constructor(first : FASTNode, second : FASTNode) { 
        super();
        this.first = first;
        this.second = second;
    }

    /**
     * Returns whether or not terminal is not a filter (disallowed)
     */
    public safeTerminal() {
        return !(this.second instanceof FilterNode);
    }

    ingressCodeGen() : string {
        return this.first.ingressCodeGen() + this.second.ingressCodeGen();
    }

    egressCodeGen() : string {
        // if (this.first instanceof Device && this.second instanceof FilterNode) {
        //     throw new Error("Cannot have filter as terminal; control reaches end of non-void function ");
        // }
        return this.first.egressCodeGen() + this.second.egressCodeGen();
    }

    /**
     * filterIngress - filters ip address, (source/dest), port
     *              and protocol of an incoming packet. Deafults to accept packet
     *              if the filtering attributes don't match that of
     *              the packet. 
     */
    public filterIngress() : ThenNode {
        return new ThenNode(this, new IngressFilterNode());
    }

    /**
     * filterEgress - filters ip address, (source/dest), port
     *                and protocol of an outgoing packet. Deafults to accept packet
     *                if the filtering attributes don't match that of
     *                the packet. 
     */
    public filterEgress() : ThenNode {
        return new ThenNode(this, new EgressFilterNode());
    }

    /**
     * Drops whatever is currently selected in the chain. E.g.
     * if you have filterIngress(), will drop what was filtered.
     */
    public drop() : ThenNode {
        return new ThenNode(this, new DropNode());
    }

    /**
     * Inserts an id node on the current chain
     * @return {ThenNode} new node with id at the end
     */
    public id() : ThenNode {
        return new ThenNode(this, new IdNode());
    }

    /**
     * inject - modifies port, ip address (source/dest)
     */
    // public inject() : ThenNode {
    //     return new ThenNode(this, new InjectNode());
    // }

    /**
     * injectIngress - modifies port, ip address of incoming packets
     */
    public injectIngress() : ThenNode {
        return new ThenNode(this, new InjectIngressNode());
    }

     /**
      * injectEgress - modifies port, ip address of outgoing packets
      */
    public injectEgress() : ThenNode {
        return new ThenNode(this, new InjectEgressNode());
    }


    /**
     * Forward - forwards an incoming packet to another destination/port pair.
     */
    public forward() : ThenNode {
        return new ThenNode(this, new ForwardNode());
    }

    /**
     * sets packet destination to ip address
     * @param ip ip address to forward to 
     */
    public to(ip : string) : ThenNode {
        if (this.second instanceof ForwardNode || this.second instanceof InjectNode) {
            this.second.setDestinationIp(ip);
        } else {
            throw new Error(`Cannot set destination ip on ${this.constructor.name}`);
        }
        return this;
    }

    /**
     * at - sets packet port to ip address
     * @param port port to forward to
     */    
     public at(port : number) {
        if (this.second instanceof ForwardNode) {
            this.second.setPort(port);
        } else {
            throw new Error(`Cannot set destination port on ${this.constructor.name}`);
        }
        return this;
    }

    /**
     * protocol - selects a protocol for filtering
     * @param proto protocol to select
     */
    public protocol(proto) : ThenNode {
        if (this.second instanceof FilterNode) {
            this.second.setProtocol(proto);
        } else {
            throw new Error(`Cannot set protocol on ${this.constructor.name}`);
        }
        return this;
    }

    /**
     * fromPort - selects an incoming port for filtering
     * @param port source port to select
     */
    public fromPort(port : number) : ThenNode {
        if (this.second instanceof FilterNode || this.second instanceof InjectNode) {
            this.second.setSourcePort(port);
        } else {
            throw new Error(`Cannot set source port on ${this.constructor.name}`);
        }
        return this;
    }

    /**
     * toPort - selects an outgoing port for filtering
     * @param port destination port to select
     */
    public toPort(port : number) : ThenNode {
        if (this.second instanceof FilterNode || this.second instanceof InjectNode) {
            this.second.setDestinationPort(port);
        } else {
            throw new Error(`Cannot set destination port on ${this.constructor.name}`);
        }
        return this;
    }

    /**
     * fromIp - selects an incoming ip for filtering
     * @param ip source ip to select
     */
    public fromIp(ip : string) : ThenNode {
        if (this.second instanceof FilterNode || this.second instanceof InjectNode) {
            this.second.setSourceIp(ip);
        } else {
            throw new Error(`Cannot set source ip on ${this.constructor.name}`);
        }
        return this;
    }


    /**
     * toIp - selects an outgoing ip for filtering
     * @param ip destination ip to select
     */
    public toIp(ip : string) : ThenNode {
        if (this.second instanceof FilterNode || this.second instanceof InjectNode) {
            this.second.setDestinationIp(ip);
        } else {
            throw new Error(`Cannot set destination ip on ${this.constructor.name}`);
        }
        return this;
    }


    /**
     * destinationMAC - selects an outgoing MAC for filtering
     * @param mac destination MAC to select
     */
    public destinationMAC(mac : string) : ThenNode {
        if (this.second instanceof FilterNode) {
            this.second.setDestinationMAC(mac);
        } else {
            throw new Error(`Cannot set destination mac on ${this.constructor.name}`);
        }
        return this;
    }
} 

export class InjectNode extends FASTNode {

    private sourcePort : Port;
    private destinationPort : Port;
    private sourceIp : Ipv4;
    private destinationIp : Ipv4;

    constructor() {
        super();
    }

    setSourcePort(port : number) : InjectNode {
        this.sourcePort = new Port(port);
        return this;
    }

    setDestinationPort(port : number) : InjectNode {
        this.destinationPort = new Port(port);
        return this;
    }

    setSourceIp(ip : string) : InjectNode {
        this.sourceIp = new Ipv4(ip);
        return this;
    }

    setDestinationIp(ip : string) : InjectNode {
        this.destinationIp = new Ipv4(ip);
        return this;
    }

    codeGen() : string {
        const code = [];

        if (this.sourcePort) {
            code.push([
                'if (ip_header->protocol == IPPROTO_TCP) {',
                '   tcp_header = tcp_hdr(sock_buff);',
                `   tcp_header->source = htons(${this.sourcePort.asNumber()});`,
                '} else if (ip_header->protocol == IPPROTO_UDP) {',
                '   udp_header = udp_hdr(sock_buff);',
                `   udp_header->source = htons(${this.sourcePort.asNumber()});`,
                '}'
            ].join('\n'));
        }

        if (this.destinationPort) {
            code.push([
                'if (ip_header->protocol == IPPROTO_TCP) {',
                '   tcp_header = tcp_hdr(sock_buff);',
                `   tcp_header->dest = htons(${this.destinationPort.asNumber()});`,
                '} else if (ip_header->protocol == IPPROTO_UDP) {',
                '   udp_header = udp_hdr(sock_buff);',
                `   udp_header->dest = htons(${this.destinationPort.asNumber()});`,
                '}'
            ].join('\n'));
        }

        if (this.sourceIp) {
            code.push(`ip_header->saddr = in_aton("${this.sourceIp.asQuad()}");`);
        }

        if (this.destinationIp) {
            code.push(`ip_header->daddr = in_aton("${this.destinationIp.asQuad()}");`);
        }

        code.push('return NF_ACCEPT; ');
        return code.join('\n');
    }

    // ingressCodeGen() : string {
    //     return this.codeGen();
    // }

    // egressCodeGen() : string {
    //     console.log("egress injection");
    //     return this.codeGen();
    // }
}


export class InjectIngressNode extends InjectNode {

    constructor() {
        super();
    }

    ingressCodeGen() : string {
        return this.codeGen();
    }
}

export class InjectEgressNode extends InjectNode {
    constructor() {
        super();
    }

    egressCodeGen() : string {
        return this.codeGen();
    }
}

export class ForwardNode extends FASTNode {

    private inject : InjectNode;

    constructor() {
        super();
        this.inject = new InjectNode();
    }

    setPort(port : number) : ForwardNode {
        this.inject.setDestinationPort(port);
        return this;
    }

    setDestinationIp(ip : string) : ForwardNode {
        this.inject.setDestinationIp(ip);
        return this;
    }

    egressCodeGen() : string {
        return this.inject.codeGen();
    }
}


// We export the chain as a constructor which takes the mac
// address of the device in which to operate the firewall rules on
export class Device extends ThenNode {

    constructor(ip : string, tag? : string) {
        super(new IdNode(), new ThenNode(
                                new IngressFilterNode()
                                    .setDestinationIp(ip),
                                new EgressFilterNode()
                                    .setSourceIp(ip)
                            )
        );
    }

    /**
     * Deploys a chain into the kernel, overwriting any loaded
     * module with the same name
     * @param FASTNode chain to deploy
     */
    public static deploy(chain : FASTNode) {
        const tempFilename = 'temp.c';
        chain.generate(tempFilename);
        exec('sh deploy.sh', (err, stdout, stderr) => {
            if (err) {
                throw new Error(err.message);
            }
            console.log(stdout);
            console.log(stderr);
        });
    }
}